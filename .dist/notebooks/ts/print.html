<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Anshik Typescript</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>‚Üê</kbd> or <kbd>‚Üí</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Anshik Typescript</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="-quick-notes"><a class="header" href="#-quick-notes">üìù Quick Notes</a></h1>
<h2 id="-number"><a class="header" href="#-number">üî¢ Number</a></h2>
<p><strong>Number</strong> is the set of all numbers: integers, floats, positives, negatives, Infinity, NaN, and so on. Numbers can do, well, numbery things, like addition (<code>+</code>), subtraction (<code>-</code>), modulo (<code>%</code>), and comparison (<code>&lt;</code>).</p>
<hr />
<h2 id="-primitives-in-jsts"><a class="header" href="#-primitives-in-jsts">üß© Primitives in JS/TS</a></h2>
<p>In JavaScript, a <strong>primitive</strong> (primitive value, primitive data type) is data that is not an object and has no methods or properties. There are <strong>7 primitive data types</strong>:</p>
<blockquote>
<p><code>string</code> ‚Ä¢ <code>number</code> ‚Ä¢ <code>bigint</code> ‚Ä¢ <code>boolean</code> ‚Ä¢ <code>undefined</code> ‚Ä¢ <code>symbol</code> ‚Ä¢ <code>null</code></p>
</blockquote>
<h3 id="key-characteristics"><a class="header" href="#key-characteristics">Key Characteristics:</a></h3>
<ul>
<li><strong>All primitives are immutable</strong> ‚Äî they cannot be altered</li>
<li>It's important not to confuse a primitive itself with a variable assigned a primitive value</li>
<li>The variable may be reassigned to a new value, but the existing value cannot be changed in the ways that objects, arrays, and functions can be altered</li>
<li>The language does not offer utilities to mutate primitive values</li>
</ul>
<h3 id="auto-boxing-behavior"><a class="header" href="#auto-boxing-behavior">Auto-boxing Behavior:</a></h3>
<p>Primitives have no methods but still behave as if they do. When properties are accessed on primitives, JavaScript <strong>auto-boxes</strong> the value into a wrapper object and accesses the property on that object instead.</p>
<p><strong>Example:</strong> <code>"foo".includes("f")</code> implicitly creates a String wrapper object and calls <code>String.prototype.includes()</code> on that object. This auto-boxing behavior is not observable in JavaScript code but is a good mental model of various behaviors ‚Äî for example, why "mutating" primitives does not work (because <code>str.foo = 1</code> is not assigning to the property <code>foo</code> of <code>str</code> itself, but to an ephemeral wrapper object).</p>
<hr />
<h2 id="-objectseal-and-objectfreeze"><a class="header" href="#-objectseal-and-objectfreeze">üîí Object.seal(...) and Object.freeze(...)</a></h2>
<h3 id="objectseal"><a class="header" href="#objectseal">Object.seal()</a></h3>
<p>In JavaScript, <code>Object.seal()</code> is used to restrict modifications to an object's structure:</p>
<ul>
<li>‚úÖ <strong>Prevents</strong> adding or deleting properties</li>
<li>‚úÖ <strong>Allows</strong> changing the values of existing ones</li>
<li>‚ö†Ô∏è <strong>Not recursive</strong> ‚Äî sealing an object does <strong>not</strong> seal its nested objects</li>
</ul>
<p>You must apply <code>Object.seal()</code> manually or via a <strong>recursive function</strong> for deeper levels.</p>
<blockquote>
<p><strong>Note:</strong> If you seal an object with nested objects inside, you can still modify those nested properties unless they are sealed individually.</p>
</blockquote>
<h3 id="objectfreeze"><a class="header" href="#objectfreeze">Object.freeze()</a></h3>
<p><code>Object.freeze()</code> makes an object completely <strong>immutable</strong> at the top level:</p>
<ul>
<li>‚ùå <strong>Prevents</strong> addition, deletion, and value updates of its properties</li>
<li>‚ö†Ô∏è Like <code>seal()</code>, <code>freeze()</code> is also <strong>shallow by default</strong></li>
<li>Nested objects remain mutable unless <strong>recursively frozen</strong> using a utility function</li>
</ul>
<h3 id="deep-sealingfreezing"><a class="header" href="#deep-sealingfreezing">Deep Sealing/Freezing</a></h3>
<p>To make an object fully sealed or frozen, including its nested levels, you need to write or use a <strong>deep sealing/freezing function</strong> that traverses and applies the method to each nested object.</p>
<blockquote>
<p><strong>Important:</strong> Both <code>seal</code> and <code>freeze</code> work only on <strong>objects</strong> ‚Äî if you try to seal or freeze a <strong>primitive value</strong> like a string or number, it has <strong>no effect</strong>.</p>
</blockquote>
<hr />
<h2 id="-is-value-a-valid-object"><a class="header" href="#-is-value-a-valid-object">‚úÖ Is value a valid Object?</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Value</th><th style="text-align: center"><code>{}</code></th><th style="text-align: center"><code>object type</code></th><th style="text-align: center"><code>Object</code></th></tr></thead><tbody>
<tr><td><code>{}</code></td><td style="text-align: center">‚úÖ</td><td style="text-align: center">‚úÖ</td><td style="text-align: center">‚úÖ</td></tr>
<tr><td><code>['a']</code></td><td style="text-align: center">‚úÖ</td><td style="text-align: center">‚úÖ</td><td style="text-align: center">‚úÖ</td></tr>
<tr><td><code>function () {}</code></td><td style="text-align: center">‚úÖ</td><td style="text-align: center">‚úÖ</td><td style="text-align: center">‚úÖ</td></tr>
<tr><td><code>new String('a')</code></td><td style="text-align: center">‚úÖ</td><td style="text-align: center">‚úÖ</td><td style="text-align: center">‚úÖ</td></tr>
<tr><td><code>'a'</code></td><td style="text-align: center">‚úÖ</td><td style="text-align: center">‚ùå</td><td style="text-align: center">‚úÖ</td></tr>
<tr><td><code>1</code></td><td style="text-align: center">‚úÖ</td><td style="text-align: center">‚ùå</td><td style="text-align: center">‚úÖ</td></tr>
<tr><td><code>Symbol('a')</code></td><td style="text-align: center">‚úÖ</td><td style="text-align: center">‚ùå</td><td style="text-align: center">‚úÖ</td></tr>
<tr><td><code>null</code></td><td style="text-align: center">‚ùå</td><td style="text-align: center">‚ùå</td><td style="text-align: center">‚ùå</td></tr>
<tr><td><code>undefined</code></td><td style="text-align: center">‚ùå</td><td style="text-align: center">‚ùå</td><td style="text-align: center">‚ùå</td></tr>
</tbody></table>
</div>
<p><strong>Reason:</strong> Some of them are primitive data types.</p>
<h2 id="misconception"><a class="header" href="#misconception">Misconception</a></h2>
<p>This is actually one of JavaScript's most famous quirks. When you use the typeof operator on null, it returns "object": javascripttypeof null // returns "object" However, this is widely considered a bug in JavaScript that has been kept for backward compatibility. According to the JavaScript specification, null is actually a primitive value, not an object.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="experiments"><a class="header" href="#experiments">Experiments</a></h1>
<h2 id="assigning-object-as-key-in-object"><a class="header" href="#assigning-object-as-key-in-object">Assigning object as key in object</a></h2>
<pre><code>
let i = {
  10: "akkkdkd",
};
const p = {
  [i]: 888,
  10:44,
};
console.log(p["[object Object]"]);
// output is 888 wtf
console.log(p[10]);
</code></pre>
<h2 id="ts-unions-and-intersections"><a class="header" href="#ts-unions-and-intersections">Ts Unions and Intersections.</a></h2>
<pre><code>  type k = {
  name: string;
  desc: string;
};
type k1 = {
  name: number;
  desc1: string;
};
type p = k | k1; //union
let mmmm: p = {
  name: 33,
  desc: "",
  desc1: "",
};
mmmm.name; // both string and number

type m = {
  name: string;
  desc: string;
};
type m1 = {
  name: number;
  desc1: string;
};
type n = m &amp; m1; //name is only comman
let mmm: n = {
  name,
};
m.name; // name is now of type never because string &amp; number is not possible at same time....

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory-management-of-objects"><a class="header" href="#memory-management-of-objects">Memory management of objects</a></h1>
<h2 id=""><a class="header" href="#"></a></h2>
<p>1</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interfaces-vs-types"><a class="header" href="#interfaces-vs-types">interfaces vs types</a></h1>
<h2 id="types"><a class="header" href="#types">Types</a></h2>
<p>Types are like which can represent any thing in typescript. everything in ts can be represented by types one<br />
For Example:</p>
<pre><code class="language-typescript">type Reservation = any;
type m = Boolean; // class
enum k {
  "akdk" = "dkkdk",
}
type l = k; // enum
type gg = number; // premitive data type
</code></pre>
<h2 id="interfaces"><a class="header" href="#interfaces">Interfaces</a></h2>
<p>But on the other hand Interfaces and only represent Object and Classes structure no other type.</p>
<pre><code class="language-typescript">interface num extends number; // no premitive data type
interface bool extends Boolean // yes it can extend class and a class can impelement interface also
interface enuum extends k // no extention from enum

</code></pre>
<p>basically it only works with object and classes</p>
<h2 id="class"><a class="header" href="#class">Class</a></h2>
<p>And a class can not implement type</p>
<pre><code class="language-typescript">class M implements Reserve {
  // wrong
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="instance-of"><a class="header" href="#instance-of">instance of</a></h1>
<pre><code class="language-typescript">class DD {}
class MM {}
class PP extends MM {}
const p = new PP();
console.log(p instanceof DD); // false
console.log(p instanceof MM); // true
/////     |||      \\\\\\
let b = true;
let mm = "dkdk";
console.log(b instanceof Boolean); // false
console.log(b instanceof String); //false
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tips"><a class="header" href="#tips">Tips</a></h1>
<ul>
<li>Always use premitive data type string , number , boolean , symbox ...etc. as key of Object.</li>
</ul>
<h1 id="buzz-words"><a class="header" href="#buzz-words">Buzz Words</a></h1>
<p>The [key: T]: U syntax is called an index signature, and this is the way you tell TypeScript that the given object might contain more keys. The way to read it is, ‚ÄúFor this object, all keys of type T must have values of type U.‚Äù</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="out-of-box-concepts-about-jsts"><a class="header" href="#out-of-box-concepts-about-jsts">Out of box concepts about js/ts.</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-iterator"><a class="header" href="#custom-iterator">Custom Iterator</a></h1>
<h2 id="what-is-iterator"><a class="header" href="#what-is-iterator">What is Iterator</a></h2>
<p>An iterator is any object that has a next() method returning { value, done }.</p>
<p>Your next() method:</p>
<pre><code class="language-javascript">next() {
  return {
    value: this.count++,    // Return the current value, then apply given operation/calculation
    done: this.count === 10 // Stop when count reaches 10
  };
}
</code></pre>
<p>Now, our object is Iterator, means can be iterate over it somehow</p>
<h2 id="how-to-make-it-iteratable"><a class="header" href="#how-to-make-it-iteratable">How to make it Iteratable??</a></h2>
<p>Use <code>[Symbol.iterator]()</code>!!! in you object. This method makes your object iterable ‚Äî it returns something that the for...of loop or spread operator (...) can use.</p>
<pre><code class="language-javascript">  [Symbol.iterator]() {
  return this;
}

</code></pre>
<p>Now when ever we will use this in spead operator or in for...of loop, javascript will look for next(), next().value, next().done in your object and till your done is not true it will keep executing next function. For example:</p>
<pre><code class="language-javascript">const anshik = {
  count: 0,
  next() {
    return {
      value: this.count++,
      done: this.count === 10,
    };
  },
  // your object is iterator
  [Symbol.iterator]() {
    return this;
  },
  // made it iterable trough spread/ for...of loop compatible
console.log([...anshik]);
for (const i of anshik) {
  console.log(i);
}
</code></pre>
<h2 id="what-is-generator"><a class="header" href="#what-is-generator">What is Generator</a></h2>
<p>A generator is a special function declared with function*, and it can be paused and resumed using the yield keyword.</p>
<pre><code class="language-javascript">function* anshik() {
  for (let i = 0; i &lt; 10; i++) {
    yield i;
  }
}

console.log([...anshik()]);
// 0,1,2....
//or
console.log(anshik.next()); //output= {value:0,done:false}
console.log(anshik.next());
console.log(anshik.next());
console.log(anshik.next());
console.log(anshik.next());
//....
// in under the hood yield key word is converted to next().value, next().done and when on next iteration of next() if yield is not defined it assumes done:true!!
</code></pre>
<h2 id="experiment-time"><a class="header" href="#experiment-time">Experiment Time!!!</a></h2>
<p>Now, if we try</p>
<pre><code class="language-javascript">const m = [
  { value: 1, done: false },
  { value: 2, done: false },
  { value: 3, done: true },
];
for (const i of m) {
  console.log(i);
}
// i will not give direct 1,2,3 and behave simply, so iterators and generators are internal js machanisums which works only in presence of yeild and [Symbol]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="array-like-objects"><a class="header" href="#array-like-objects">Array-Like Objects</a></h1>
<p>An array-like object is any object with a <code>length</code> property and indexed elements (numeric keys like 0, 1, etc.).</p>
<pre><code class="language-javascript">const m = {
  length: 10,
};
// This object behaves like an array in structure,
// but it doesn't inherit array methods like push, map, filter, etc.
</code></pre>
<h2 id="-converting-to-array"><a class="header" href="#-converting-to-array">‚úÖ Converting to Array</a></h2>
<p>If the array-like object has keys in a sequence from 0 to length - 1, we can convert it to a real array using <code>Array.from()</code>:</p>
<pre><code class="language-javascript">const kk = {
  0: 20,
  1: 3,
  2: 4,
  3: 11,
  length: 4,
};
const arr = Array.from(kk);
console.log(arr); // [20, 3, 4, 11]
</code></pre>
<h2 id="-edge-cases--behavior"><a class="header" href="#-edge-cases--behavior">‚ö†Ô∏è Edge Cases &amp; Behavior</a></h2>
<h3 id="1-missing-indices--undefined"><a class="header" href="#1-missing-indices--undefined">1. Missing Indices ‚Üí undefined</a></h3>
<pre><code class="language-javascript">const obj = {
  0: "a",
  2: "b",
  length: 3,
};
console.log(Array.from(obj)); // ['a', undefined, 'b']
</code></pre>
<h3 id="2-non-numeric-keys-are-ignored"><a class="header" href="#2-non-numeric-keys-are-ignored">2. Non-numeric Keys Are Ignored</a></h3>
<pre><code class="language-javascript">const obj = {
  0: "x",
  1: "y",
  foo: "bar",
  length: 2,
};
console.log(Array.from(obj)); // ['x', 'y']
</code></pre>
<h3 id="3-length-as-string-or-non-numeric"><a class="header" href="#3-length-as-string-or-non-numeric">3. length as String or Non-numeric</a></h3>
<pre><code class="language-javascript">const obj = {
  0: "a",
  1: "b",
  length: "2",
};
console.log(Array.from(obj)); // ['a', 'b']
</code></pre>
<pre><code class="language-javascript">const bad = {
  0: "x",
  1: "y",
  length: "abc",
};
console.log(Array.from(bad)); // []
</code></pre>
<h3 id="4-float-length-is-floored"><a class="header" href="#4-float-length-is-floored">4. Float length is Floored</a></h3>
<pre><code class="language-javascript">const obj = {
  0: "a",
  1: "b",
  2: "c",
  length: 2.7,
};
console.log(Array.from(obj)); // ['a', 'b']
</code></pre>
<h3 id="5-mapping-function-in-arrayfrom"><a class="header" href="#5-mapping-function-in-arrayfrom">5. Mapping Function in Array.from()</a></h3>
<pre><code class="language-javascript">const obj = {
  0: 2,
  1: 3,
  2: 4,
  length: 3,
};
const result = Array.from(obj, (value) =&gt; value * 2);
console.log(result); // [4, 6, 8]
</code></pre>
<h3 id="6-real-world-example-arguments"><a class="header" href="#6-real-world-example-arguments">6. Real World Example: arguments</a></h3>
<pre><code class="language-javascript">function example() {
  const args = Array.from(arguments);
  console.log(args); // ['a', 'b', 'c']
}
example("a", "b", "c");
</code></pre>
<h2 id="key-takeaways"><a class="header" href="#key-takeaways">Key Takeaways</a></h2>
<ul>
<li>Array-like objects have <code>length</code> property and numeric indices</li>
<li><code>Array.from()</code> converts them to real arrays with all array methods</li>
<li>Missing indices become <code>undefined</code> in the resulting array</li>
<li>Non-numeric properties are ignored during conversion</li>
<li>String lengths are coerced to numbers, invalid strings result in empty arrays</li>
<li>Float lengths are floored to integers</li>
<li>Mapping function can transform values during conversion</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ts-book"><a class="header" href="#ts-book">TS Book</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="when-and-where-to-use-unkown-"><a class="header" href="#when-and-where-to-use-unkown-">When and where to use unkown ?</a></h1>
<h2 id="intro"><a class="header" href="#intro">intro</a></h2>
<p>For the few cases where you have a value whose type you really don‚Äôt know ahead of time, don‚Äôt use any, and instead reach for unknown. Like any, it represents any value, but TypeScript won‚Äôt let you use an unknown type until you refine it by checking what it is</p>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<pre><code>let a: unknown = 30 // unknown
let b = a === 123 // boolean
let c = a + 10 // Error TS2571: Object is of type 'unknown'.
if (typeof a === 'number') {
  let d = a + 10 // number
}
</code></pre>
<p>
TypeScript will never infer something as unknown‚Äîyou have to explicitly annotate it. You can compare values to values that are of type unknown. But, you can‚Äôt do things that assume an unknown value is of a specific type (c);
you have to prove to TypeScript that the value really is of that type first (d).
</p>
<h2 id="dealing-with-big-objects-like-and-api-response-is-set-to-unkown"><a class="header" href="#dealing-with-big-objects-like-and-api-response-is-set-to-unkown">Dealing with big objects like and api response is set to unkown</a></h2>
<p>How can we deal with it??</p>
<pre><code class="language-typescript">const bigObject: unknown = {
  name: "Anshik",
  age: 24,
  details: {
    address: "Delhi",
    phone: "123456",
  },
};

if (
  typeof bigObject === "object" &amp;&amp;
  bigObject !== null &amp;&amp;
  "name" in bigObject
) {
  // to access name file
  const name = (bigObject as any).name;

  // now to access phone field
  if (
    typeof data === "object" &amp;&amp;
    data !== null &amp;&amp;
    "details" in data &amp;&amp;
    typeof (data as any).details === "object" &amp;&amp;
    (data as any).details !== null &amp;&amp;
    "phone" in (data as any).details
  ) {
    const phone = (data as any).details.phone;
    console.log(phone); // "123456"
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="empty-object-type"><a class="header" href="#empty-object-type">Empty Object Type</a></h1>
<pre><code>// empty object literal (object litral =&gt; syntax to write an object {...}. )
if ({}) {
  console.log("Anshik");
} else {
  console.log("dkkdk");
}
// output is anshik
	
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arrays-in-ts"><a class="header" href="#arrays-in-ts">Arrays in ts</a></h1>
<pre><code>let a = [1, 2, 3];                // number[]
var b = ['a', 'b'];              // string[]
let c: string[] = ['a'];         // string[]
let d = [1, 'a'];                // (string | number)[]
const e = [2, 'b'];              // (string | number)[]

let f = ['red'];                 // string[]
f.push('blue');                  // OK
f.push(true);                    // ‚ùå Error: Argument of type 'true' is not assignable to parameter of type 'string'

let g = [];                      // any[]
g.push(1);                       // number[]
g.push('red');                   // (string | number)[]

let h: number[] = [];            // number[]
h.push(1);                       // OK
h.push('red');                   // ‚ùå Error: Argument of type '"red"' is not assignable to parameter of type 'number'

</code></pre>
<p>The default behaviour of typescript if we don't provide any type is to keep everything homogenious only of one type with with which the object was initialized.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="null-undefined-void-and-never"><a class="header" href="#null-undefined-void-and-never">Null, Undefined, Void and Never</a></h1>
<h2 id="null-and-undefined"><a class="header" href="#null-and-undefined">Null and Undefined</a></h2>
<p>undefined type means the type has not been yet defined. And null means absence of a value it is defined but absent it is defined but can we access or not we don't know.</p>
<h2 id="void-and-never"><a class="header" href="#void-and-never">Void and Never</a></h2>
<p>Functions that never return (throw, infinite loops) are inferred as returning never by good ts programmers.<br/> void means a function will execute completly. for its scope.</p>
<h2 id="unkown-and-never"><a class="header" href="#unkown-and-never">unkown and never</a></h2>
<pre><code>// unknown is the supertype of all types
let value: unknown;

value = 42;         // OK
value = "hello";    // OK
value = true;       // OK
value = { x: 1 };   // OK
// a variable of type unkown can accept any type of value as given
</code></pre>
<pre><code>// at the same time never is the subtype of all types ‚Üí Bottom type

let neverValue: never;

// You can assign `never` to any type:
let str: string = neverValue;
let num: number = neverValue; // err str is assign berfore initialization but its not giving type error
// OR

function k(): never {
  throw TypeError("eee");
}
let m: string = k();


// a variable of type never can be assigned to any type or it is accepted by any type in ts.

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enums"><a class="header" href="#enums">Enums</a></h1>
<p>There are two kinds of enums: enums that map from strings to strings, and enums that map from strings to numbers. They look like this:</p>
<pre><code>enum Language {
English = 0,
Spanish = 1
enum Language {
Russian = 2
}
}
enum Language { English, Spanish, Russian } // ts automatically merge types
</code></pre>
<pre><code>enum Language {
English = 100,
Spanish = 200 + 300,
Russian // TypeScript infers 501 (the next number after 500)
}
</code></pre>
<p>Language[6] // ts won't give error<br/> use enum with const to disable unsafe access like Language[6]</p>
<pre><code>  const enum Language {
English,
Spanish,
Russian
}
let d = Language[6] // Error TS2476: A const enum member can only be
// accessed using a string literal.
</code></pre>
<p>but it also can generate issue as shown inbook page 43 <br/> TSC Flag: preserveConstEnums<br/> use string to string relation ship in const based enums to avoid any miscalculations <br/></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions-bindcall-and-apply"><a class="header" href="#functions-bindcall-and-apply">Functions Bind,Call and Apply</a></h1>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p><code>call()</code>, <code>apply()</code>, and <code>bind()</code> are JavaScript methods that allow you to control the <code>this</code> context of functions. They're essential for function borrowing, method chaining, and controlling execution context.</p>
<h2 id="the-call-method"><a class="header" href="#the-call-method">The <code>call()</code> Method</a></h2>
<h3 id="syntax"><a class="header" href="#syntax">Syntax</a></h3>
<pre><code class="language-javascript">function.call(thisArg, arg1, arg2, ...)
</code></pre>
<h3 id="basic-example"><a class="header" href="#basic-example">Basic Example</a></h3>
<pre><code class="language-javascript">const person = {
  firstName: "John",
  lastName: "Doe",
  fullName: function () {
    return this.firstName + " " + this.lastName;
  },
};

const anotherPerson = {
  firstName: "Jane",
  lastName: "Smith",
};

// Using call to borrow the fullName method
console.log(person.fullName.call(anotherPerson)); // "Jane Smith"
</code></pre>
<h3 id="example-with-arguments"><a class="header" href="#example-with-arguments">Example with Arguments</a></h3>
<pre><code class="language-javascript">const calculator = {
  multiply: function (a, b) {
    return a * b * this.factor;
  },
};

const config = { factor: 10 };

// Using call with arguments
const result = calculator.multiply.call(config, 5, 3);
console.log(result); // 150 (5 * 3 * 10)
</code></pre>
<h3 id="practical-use-case---function-borrowing"><a class="header" href="#practical-use-case---function-borrowing">Practical Use Case - Function Borrowing</a></h3>
<pre><code class="language-javascript">const arrayLike = {
  0: "apple",
  1: "banana",
  2: "cherry",
  length: 3,
};

// Borrowing Array methods
const fruits = Array.prototype.slice.call(arrayLike);
console.log(fruits); // ['apple', 'banana', 'cherry']

// Converting NodeList to Array
const divs = document.querySelectorAll("div");
const divsArray = Array.prototype.slice.call(divs);
</code></pre>
<h2 id="the-apply-method"><a class="header" href="#the-apply-method">The <code>apply()</code> Method</a></h2>
<h3 id="syntax-1"><a class="header" href="#syntax-1">Syntax</a></h3>
<pre><code class="language-javascript">function.apply(thisArg, [argsArray])
</code></pre>
<h3 id="basic-example-1"><a class="header" href="#basic-example-1">Basic Example</a></h3>
<pre><code class="language-javascript">const numbers = [1, 2, 3, 4, 5];

// Finding maximum using Math.max with apply
const max = Math.max.apply(null, numbers);
console.log(max); // 5

// Modern alternative with spread operator
const maxModern = Math.max(...numbers);
</code></pre>
<h3 id="example-with-context"><a class="header" href="#example-with-context">Example with Context</a></h3>
<pre><code class="language-javascript">const greetings = {
  prefix: "Hello",
  greet: function (name, punctuation) {
    return `${this.prefix} ${name}${punctuation}`;
  },
};

const formalGreeting = { prefix: "Good morning" };

// Using apply with arguments array
const message = greetings.greet.apply(formalGreeting, ["Mr. Johnson", "."]);
console.log(message); // "Good morning Mr. Johnson."
</code></pre>
<h3 id="practical-use-case---array-operations"><a class="header" href="#practical-use-case---array-operations">Practical Use Case - Array Operations</a></h3>
<pre><code class="language-javascript">const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];

// Concatenating arrays using apply
arr1.push.apply(arr1, arr2);
console.log(arr1); // [1, 2, 3, 4, 5, 6]

// Finding min/max in nested arrays
const nestedArray = [
  [1, 2],
  [3, 4],
  [5, 6],
];
const flattened = [].concat.apply([], nestedArray);
console.log(flattened); // [1, 2, 3, 4, 5, 6]
</code></pre>
<h2 id="the-bind-method"><a class="header" href="#the-bind-method">The <code>bind()</code> Method</a></h2>
<h3 id="syntax-2"><a class="header" href="#syntax-2">Syntax</a></h3>
<pre><code class="language-javascript">function.bind(thisArg, arg1, arg2, ...)
</code></pre>
<h3 id="basic-example-2"><a class="header" href="#basic-example-2">Basic Example</a></h3>
<pre><code class="language-javascript">const module = {
  x: 42,
  getX: function () {
    return this.x;
  },
};

const unboundGetX = module.getX;
console.log(unboundGetX()); // undefined (this is not module)

const boundGetX = unboundGetX.bind(module);
console.log(boundGetX()); // 42
</code></pre>
<h3 id="event-handling-example"><a class="header" href="#event-handling-example">Event Handling Example</a></h3>
<pre><code class="language-javascript">class Button {
  constructor(element) {
    this.element = element;
    this.clickCount = 0;

    // Binding ensures 'this' refers to the Button instance
    this.element.addEventListener("click", this.handleClick.bind(this));
  }

  handleClick() {
    this.clickCount++;
    console.log(`Button clicked ${this.clickCount} times`);
  }
}

const button = new Button(document.getElementById("myButton"));
</code></pre>
<h3 id="partial-application-currying"><a class="header" href="#partial-application-currying">Partial Application (Currying)</a></h3>
<pre><code class="language-javascript">function multiply(a, b, c) {
  return a * b * c;
}

// Creating a function with pre-filled arguments
const multiplyByTwo = multiply.bind(null, 2);
console.log(multiplyByTwo(3, 4)); // 24 (2 * 3 * 4)

const multiplyByTwoAndThree = multiply.bind(null, 2, 3);
console.log(multiplyByTwoAndThree(4)); // 24 (2 * 3 * 4)
</code></pre>
<h2 id="comparison-table"><a class="header" href="#comparison-table">Comparison Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Returns</th><th>Arguments</th><th>Use Case</th></tr></thead><tbody>
<tr><td><code>call()</code></td><td>Executes immediately</td><td>Individual arguments</td><td>Immediate execution with specific context</td></tr>
<tr><td><code>apply()</code></td><td>Executes immediately</td><td>Array of arguments</td><td>Immediate execution with array arguments</td></tr>
<tr><td><code>bind()</code></td><td>Returns new function</td><td>Individual arguments</td><td>Creating bound functions for later use</td></tr>
</tbody></table>
</div>
<h2 id="advanced-examples"><a class="header" href="#advanced-examples">Advanced Examples</a></h2>
<h3 id="method-chaining-with-different-contexts"><a class="header" href="#method-chaining-with-different-contexts">Method Chaining with Different Contexts</a></h3>
<pre><code class="language-javascript">const logger = {
  log: function (message) {
    console.log(`[${this.level}]: ${message}`);
    return this;
  },
};

const errorLogger = { level: "ERROR" };
const infoLogger = { level: "INFO" };

// Creating bound methods
const logError = logger.log.bind(errorLogger);
const logInfo = logger.log.bind(infoLogger);

logError("Something went wrong"); // [ERROR]: Something went wrong
logInfo("Process completed"); // [INFO]: Process completed
</code></pre>
<h3 id="function-composition"><a class="header" href="#function-composition">Function Composition</a></h3>
<pre><code class="language-javascript">const operations = {
  add: function (a, b) {
    return a + b;
  },
  multiply: function (a, b) {
    return a * b;
  },
  chain: function (value) {
    this.value = value;
    return this;
  },
  result: function () {
    return this.value;
  },
};

// Using bind for function composition
const calculator = {
  value: 0,
  add: operations.add.bind(operations),
  multiply: operations.multiply.bind(operations),
  chain: operations.chain.bind(operations),
  result: operations.result.bind(operations),
};
</code></pre>
<h3 id="polyfill-examples"><a class="header" href="#polyfill-examples">Polyfill Examples</a></h3>
<pre><code class="language-javascript">// Simple bind polyfill (for understanding)
if (!Function.prototype.bind) {
  Function.prototype.bind = function (oThis) {
    if (typeof this !== "function") {
      throw new TypeError(
        "Function.prototype.bind - what is trying to be bound is not callable",
      );
    }

    const aArgs = Array.prototype.slice.call(arguments, 1);
    const fToBind = this;
    const fBound = function () {
      return fToBind.apply(
        this instanceof fBound ? this : oThis,
        aArgs.concat(Array.prototype.slice.call(arguments)),
      );
    };

    fBound.prototype = Object.create(this.prototype);
    return fBound;
  };
}
</code></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="1-use-arrow-functions-for-lexical-binding"><a class="header" href="#1-use-arrow-functions-for-lexical-binding">1. Use Arrow Functions for Lexical Binding</a></h3>
<pre><code class="language-javascript">class Timer {
  constructor() {
    this.seconds = 0;

    // Arrow function preserves 'this'
    setInterval(() =&gt; {
      this.seconds++;
      console.log(this.seconds);
    }, 1000);
  }
}
</code></pre>
<h3 id="2-avoid-overusing-bind-in-render-methods"><a class="header" href="#2-avoid-overusing-bind-in-render-methods">2. Avoid Overusing bind() in Render Methods</a></h3>
<pre><code class="language-javascript">// Bad - creates new function on every render
class BadComponent {
  render() {
    return &lt;button onClick={this.handleClick.bind(this)}&gt;Click&lt;/button&gt;;
  }
}

// Good - bind in constructor
class GoodComponent {
  constructor() {
    this.handleClick = this.handleClick.bind(this);
  }

  render() {
    return &lt;button onClick={this.handleClick}&gt;Click&lt;/button&gt;;
  }
}
</code></pre>
<h3 id="3-performance-considerations"><a class="header" href="#3-performance-considerations">3. Performance Considerations</a></h3>
<pre><code class="language-javascript">// Bind once and reuse
const boundFunction = someFunction.bind(context);

// Rather than binding multiple times
// someFunction.bind(context)();
// someFunction.bind(context)();
</code></pre>
<h2 id="common-pitfalls"><a class="header" href="#common-pitfalls">Common Pitfalls</a></h2>
<h3 id="1-losing-context-in-callbacks"><a class="header" href="#1-losing-context-in-callbacks">1. Losing Context in Callbacks</a></h3>
<pre><code class="language-javascript">const obj = {
  name: "MyObject",
  delay: function () {
    // Wrong - 'this' will be undefined or window
    setTimeout(function () {
      console.log(this.name);
    }, 1000);

    // Correct - using bind
    setTimeout(
      function () {
        console.log(this.name);
      }.bind(this),
      1000,
    );

    // Modern solution - arrow function
    setTimeout(() =&gt; {
      console.log(this.name);
    }, 1000);
  },
};
</code></pre>
<h3 id="2-method-references"><a class="header" href="#2-method-references">2. Method References</a></h3>
<pre><code class="language-javascript">const obj = {
  value: 42,
  getValue: function () {
    return this.value;
  },
};

// Wrong - loses context
const getValue = obj.getValue;
console.log(getValue()); // undefined

// Correct - maintain context
const boundGetValue = obj.getValue.bind(obj);
console.log(boundGetValue()); // 42
</code></pre>
<h2 id="modern-alternatives"><a class="header" href="#modern-alternatives">Modern Alternatives</a></h2>
<h3 id="using-spread-operator-instead-of-apply"><a class="header" href="#using-spread-operator-instead-of-apply">Using Spread Operator Instead of Apply</a></h3>
<pre><code class="language-javascript">// Old way with apply
Math.max.apply(null, [1, 2, 3, 4, 5]);

// Modern way with spread
Math.max(...[1, 2, 3, 4, 5]);
</code></pre>
<h3 id="using-arrow-functions-instead-of-bind"><a class="header" href="#using-arrow-functions-instead-of-bind">Using Arrow Functions Instead of Bind</a></h3>
<pre><code class="language-javascript">// Using bind
const boundFunction = regularFunction.bind(this);

// Using arrow function (when appropriate)
const arrowFunction = (...args) =&gt; regularFunction.apply(this, args);
</code></pre>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<ul>
<li><strong><code>call()</code></strong>: Invokes function immediately with specified <code>this</code> and individual arguments</li>
<li><strong><code>apply()</code></strong>: Invokes function immediately with specified <code>this</code> and array of arguments</li>
<li><strong><code>bind()</code></strong>: Returns new function with specified <code>this</code> and optional pre-filled arguments</li>
<li>All three methods are crucial for controlling function execution context</li>
<li>Modern JavaScript provides alternatives like arrow functions and spread operator</li>
<li>Choose the right method based on whether you need immediate execution or a bound function for later use</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extend-of-types-and-interfaces"><a class="header" href="#extend-of-types-and-interfaces">Extend of types and interfaces</a></h1>
<p>type are extended using union operators and interfaces are extended using extend keyword</p>
<h2 id="interface"><a class="header" href="#interface">interface</a></h2>
<pre><code class="language-typescript">const m = {
  name: "nashi",
};

interface k {
  name: string;
}

interface p extends k {
  description: string;
}

const mmm: p = {
  name: "anhsik",
  description: "dkdkk",
};

const ggg: k = mmm;
// ggg.description // undefined
// inteface follows same java concepts like inheritance, extension and interfaces
</code></pre>
<h2 id="types-1"><a class="header" href="#types-1">types</a></h2>
<pre><code class="language-typescript">// Base type
type K = {
  name: string;
};

// Extended type (like subclassing)
type P = K &amp; {
  description: string;
};

// Object of extended type
const mmm: P = {
  name: "anhsik",
  description: "dkdkk",
};

// Assigning subtype to base type ‚Äî works because of structural typing
const ggg: K = mmm;
// ggg.description // undefined
// like java inheritance
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overloaded-function-types"><a class="header" href="#overloaded-function-types">Overloaded Function Types</a></h1>
<p>Signature call is syntax in ts to prodifine prototype/type of function. There are two type to write a signature call.</p>
<h2 id="first-is-short-hand-signature-call"><a class="header" href="#first-is-short-hand-signature-call">First is Short hand signature call.</a></h2>
<pre><code class="language-typescript">type Log = (message: string, userId?: string) =&gt; void;
</code></pre>
<p>as simple as that</p>
<h2 id="second-is-full-call-signature"><a class="header" href="#second-is-full-call-signature">Second is Full Call Signature</a></h2>
<pre><code class="language-typescript">type Log = {
  (message: string, userId?: string): void;
};
</code></pre>
<p>Now, Full Call Signature comes with very very powerful feature of TypeScript: the ability to overload function types</p>
<p>For Example,</p>
<pre><code class="language-typescript">type Reserve = {
  (from: Date, to: Date, destination: string): Reservation;
  (destination: string): Reservation;
};
</code></pre>
<p>In languages like java, C++. We can accomplish this using function overloading, but for each overloading we need to define body of that overloaded method below it. one<br />
but in typescript we define all type of body content in same function. one<br />
For Example:</p>
<pre><code class="language-typescript">type Reserve = {
  (from: Date, to: Date, destination: string): Reservation;
  (destination: string): Reservation;
};
let reserve: Reserve = (arg1: Date | string, arg2?: Date, arg3?: string) =&gt; {
  if (typeof arg1 === "string") {
    // we can use instanceof class, or other operators also
    // Called as: reserve("Bali")
    return { destination: arg1 };
  } else {
    // Called as: reserve(date1, date2, "Bali")
    return { from: arg1, to: arg2, destination: arg3 };
  }
};
</code></pre>
<p>In Typescript we handle all type of edge cases for that function in same body. one<br />
Also,</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="strings-in-jsts"><a class="header" href="#strings-in-jsts">Strings in js/ts</a></h1>
<h2 id="string-defination"><a class="header" href="#string-defination">String defination</a></h2>
<p>When String() is called as a function (without new), it returns value coerced to a string primitive. one<br />
But When String() is called as a constructor (with new), it coerces value to a string primitive (without special symbol handling) and returns a wrapping String object, which is not a primitive. one<br />
For Example:</p>
<pre><code class="language-typescript">const a = new String("Hello world"); // a === "Hello world" is false
const b = String("Hello world"); // b === "Hello world" is true
a instanceof String; // is true
b instanceof String; // is false
typeof a; // "object"
typeof b; // "string"
</code></pre>
<h2 id="string-behaviour-with-symbols"><a class="header" href="#string-behaviour-with-symbols">String behaviour with Symbols</a></h2>
<pre><code class="language-typescript">const sym = Symbol("example");
`${sym}`; // TypeError: Cannot convert a Symbol value to a string
"" + sym; // TypeError: Cannot convert a Symbol value to a string
"".concat(sym); // TypeError: Cannot convert a Symbol value to a string
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
